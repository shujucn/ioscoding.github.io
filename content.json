{"meta":{"title":"iOS Coding","subtitle":"iOS 编程之路","description":null,"author":"shujucn","url":"http://ioscoding.cn"},"pages":[{"title":"about","date":"2017-05-22T03:44:58.000Z","updated":"2017-05-22T03:44:58.000Z","comments":true,"path":"about/index.html","permalink":"http://ioscoding.cn/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"categories","date":"2017-05-22T03:46:49.000Z","updated":"2017-05-22T03:48:38.000Z","comments":true,"path":"categories/index.html","permalink":"http://ioscoding.cn/categories/index.html","excerpt":"","text":"title: categories date: 2017-05-22 11:46:49","raw":null,"content":null},{"title":"tag1","date":"2017-05-22T03:46:21.000Z","updated":"2017-05-22T03:48:21.000Z","comments":true,"path":"tags/index.html","permalink":"http://ioscoding.cn/tags/index.html","excerpt":"","text":"title: tag2 date: 2017-05-22 11:46:21 title: tag3 date: 2017-05-22 11:46:21","raw":null,"content":null}],"posts":[{"title":"NSUserDefaults使用","slug":"NSUser​Defaults","date":"2016-08-16T10:19:10.000Z","updated":"2017-05-16T10:55:46.000Z","comments":true,"path":"2016/08/16/NSUser​Defaults/","link":"","permalink":"http://ioscoding.cn/2016/08/16/NSUser​Defaults/","excerpt":"","text":"NSUserDefaults官方文档NSUserDefaultsNSUserDefaults 是iOS Foundation 框架提供的一种用于存储管理单例。 Tip 1：支持存储的类型 NSArray NSData NSDictionary NSNumber NSString 通过NSData可以存储大部分类型的文件，例如要存储一张图片可以先把图片转为NSData。 // Create instances of NSData NSData *imageData = UIImageJPEGRepresentation(contactImage, 100); // Store the data NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject:imageData forKey:@&quot;image&quot;]; Tip 2: 存储使用方法NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setInteger:9001 forKey:@&quot;HighScore&quot;]; [defaults synchronize]; Tip 3: 获取存储的data// Get the stored data before the view loads NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; NSData *imageData = [defaults dataForKey:@&quot;image&quot;]; UIImage *contactImage = [UIImage imageWithData:imageData]; Tip 4: 对于常见的值类型，如Bool，Float，Integer 等可以使用系统提供的一些方法来存储不同类型值。- setBool:forKey: - setFloat:forKey: - setInteger:forKey: - setDouble:forKey: - setURL:forKey: 对于存储Bool类型值，取值的时候需要注意使用Bool变量来接住，而不是直接判断对[[NSUserDefaults standardUserDefaults] boolForKey:]，直接判断表示[NSUserDefaults standardUserDefaults] 是否能取到对应的Key值，YES表示has value，NO表示no value。 [[NSUserDefaults standardUserDefaults] setBool:YES forKey:APP_IS_FIRST_SESSION_ID]; BOOL flag = [[NSUserDefaults standardUserDefaults] boolForKey:APP_IS_FIRST_SESSION_ID]; //这里的Flag为YES if ([[NSUserDefaults standardUserDefaults] boolForKey:APP_IS_FIRST_SESSION_ID]) { //直接对取值判断，将总是True，这个代表[NSUserDefaults standardUserDefaults]能取到值 } Tip 5: NSUserDefaults域user defaults数据库中其实是由多个层级的域组成的，当你读取一个键值的数据时，NSUserDefaults从上到下透过域的层级寻找正确的值，不同的域有不同的功能，有些域是可持久的，有些域则不行。 应用域（application domain）是最重要的域，它存储着你app通过NSUserDefaultsset…forKey添加的设置。 注册域（registration domain）仅有较低的优先权，只有在应用域没有找到值时才从注册域去寻找。 全局域（global domain）则存储着系统的设置 语言域（language-specific domains）则包括地区、日期等 参数域（ argument domain）有最高优先权 注意需要在每次启动app并且没有在user defaules中读取数据的时候调用以上方法，因为registerDefaults:不能把这些默认数据存储到硬盘上，所以application:didFinishLaunchingWithOptions是最合适的地方。 NSURL *defaultPrefsFile = [[NSBundle mainBundle] URLForResource:@&quot;DefaultPreferences&quot; withExtension:@&quot;plist&quot;]; NSDictionary *defaultPrefs = [NSDictionary dictionaryWithContentsOfURL:defaultPrefsFile]; [[NSUserDefaults standardUserDefaults] registerDefaults:defaultPrefs]; 这样做的原因是：默认情况下，应用域是空的，没见键也没有值。当应用第一次设置某项用户偏好设置的值时，相应的值会通过指定的键加入应用域。当通过NSUserDefaults获取某项用户偏好设置的值时，NSUserDefaults会先在应用域中查找，如果找到了值，NSUserDefaults就会返回这个值。如果没有找到，NSUserDefaults就会在注册域中查找并返回默认值。user defaults数据库中其实是由多个层级的域组成的，当你读取一个键值的数据时，NSUserDefaults从上到下透过域的层级寻找正确的值，不同的域有不同的功能，有些域是可持久的，有些域则不行。","raw":null,"content":null,"categories":[{"name":"数据库及存储","slug":"数据库及存储","permalink":"http://ioscoding.cn/categories/数据库及存储/"}],"tags":[{"name":"NSUserDefaults","slug":"NSUserDefaults","permalink":"http://ioscoding.cn/tags/NSUserDefaults/"}]},{"title":"GCD概要及实现原理","slug":"OAuth 2.0","date":"2016-02-16T03:49:37.000Z","updated":"2017-05-16T10:55:57.000Z","comments":true,"path":"2016/02/16/OAuth 2.0/","link":"","permalink":"http://ioscoding.cn/2016/02/16/OAuth 2.0/","excerpt":"","text":"OAuth 2.0 学习笔记。主要参考资料为RFC 6749. OAuth协议 OAuth(开放授权)是一个开放标准。允许第三方网站在用户授权的前提下访问在用户在服务商那里存储的各种信息。而这种授权无需将用户提供用户名和密码提供给该第三方网站。 OAuth允许用户提供一个令牌给第三方网站，一个令牌对应一个特定的第三方网站，同时该令牌只能在特定的时间内访问特定的资源。 OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。 OAuth的原理和授权流程 OAuth的认证和授权的过程中涉及的三方包括： 服务商：用户使用服务的提供方，一般用来存消息、储照片、视频、联系人、文件等(比如Twitter、Sina微波等)。用户：服务商的用户 第三方：通常是网站，该网站想要访问用户存储在服务商那里的信息。比如某个提供照片打印服务的网站，用户想在那里打印自己存在服务商那里的网络相册。 在认证过程之前，第三方需要先向服务商申请第三方服务的唯一标识。OAuth 2.0的运行流程如下图，摘自RFC 6749。1234567891011121314151617181920* +--------+ +---------------+ | |--(A)- Authorization Request -&gt;| Resource | | | | Owner | | |&lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --&gt;| Authorization | | Client | | Server | | |&lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------&gt;| Resource | | | | Server | | |&lt;-(F)--- Protected Resource ---| | +--------+ +---------------+ Figure 1: Abstract Protocol Flow OAuth认证和授权的过程如下： 123456（A）用户打开客户端以后，客户端要求用户给予授权。（B）用户同意给予客户端授权。（C）客户端使用上一步获得的授权，向认证服务器申请令牌。（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。（E）客户端使用令牌，向资源服务器申请获取资源。（F）资源服务器确认令牌无误，同意向客户端开放资源。 详细过程如下： 用户访问第三方网站网站，想对用户存放在服务商的某些资源进行操作。 第三方网站向服务商请求一个临时令牌。 服务商验证第三方网站的身份后，授予一个临时令牌。 第三方网站获得临时令牌后，将用户导向至服务商的授权页面请求用户授权，然后这个过程中将临时令牌和第三方网站的返回地址发送给服务商。 用户在服务商的授权页面上输入自己的用户名和密码，授权第三方网站访问所相应的资源。 授权成功后，服务商将用户导向第三方网站的返回地址。 第三方网站根据临时令牌从服务商那里获取访问令牌。 服务商根据令牌和用户的授权情况授予第三方网站访问令牌。 第三方网站使用获取到的访问令牌访问存放在服务商的对应的用户资源。 客户端授权模式不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。 1234* 授权码模式（authorization code）* 简化模式（implicit）* 密码模式（resource owner password credentials）* 客户端模式（client credentials） 授权码模式授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。 1234567891011121314151617181920212223242526* +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ----&gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---&gt;| Server | | | | | | -+----(C)-- Authorization Code ---&lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |&gt;---(D)-- Authorization Code ---------&apos; | | Client | &amp; Redirection URI | | | | | |&lt;---(E)----- Access Token -------------------&apos; +---------+ (w/ Optional Refresh Token) 它的步骤如下： 12345（A）用户访问客户端，后者将前者导向认证服务器。（B）用户选择是否给予客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的&quot;重定向URI&quot;（redirection URI），同时附上一个授权码。（D）客户端收到授权码，附上早先的&quot;重定向URI&quot;，向认证服务器申请令牌。这 一步是在客户端的后台的服务器上完成的，对用户不可见。（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。 简化模式简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 1234567891011121314151617181920212223242526272829303132333435363738* +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- &amp; Redirection URI ---&gt;| | | User- | | Authorization | | Agent -|----(B)-- User authenticates --&gt;| Server | | | | | | |&lt;---(C)--- Redirection URI ----&lt;| | | | with Access Token +---------------+ | | in Fragment | | +---------------+ | |----(D)--- Redirection URI ----&gt;| Web-Hosted | | | without Fragment | Client | | | | Resource | | (F) |&lt;---(E)------- Script ---------&lt;| | | | +---------------+ +-|--------+ | | (A) (G) Access Token | | ^ v +---------+ | | | Client | | | +---------+ Note: The lines illustrating steps (A) and (B) are broken into two parts as they pass through the user-agent. Figure 4: Implicit Grant Flow 步骤如下： 1234567（A）客户端将用户导向认证服务器。（B）用户决定是否给于客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端指定的&quot;重定向URI&quot;，并在URI的Hash部分包含了访问令牌。（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。（F）浏览器执行上一步获得的脚本，提取出令牌。（G）浏览器将令牌发给客户端。 密码模式密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。 在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。 1234567891011121314151617181920* +----------+ | Resource | | Owner | | | +----------+ v | Resource Owner (A) Password Credentials | v +---------+ +---------------+ | |&gt;--(B)---- Resource Owner -------&gt;| | | | Password Credentials | Authorization | | Client | | Server | | |&lt;--(C)---- Access Token ---------&lt;| | | | (w/ Optional Refresh Token) | | +---------+ +---------------+ Figure 5: Resource Owner Password Credentials Flow 步骤如下： 123（A）用户向客户端提供用户名和密码。（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。（C）认证服务器确认无误后，向客户端提供访问令牌。 客户端模式客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。 12345678910* +---------+ +---------------+ | | | | | |&gt;--(A)- Client Authentication ---&gt;| Authorization | | Client | | Server | | |&lt;--(B)---- Access Token ---------&lt;| | | | | | +---------+ +---------------+ Figure 6: Client Credentials Flow 它的步骤如下： 12（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。（B）认证服务器确认无误后，向客户端提供访问令牌。 注意：如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。","raw":null,"content":null,"categories":[{"name":"网络和线程","slug":"网络和线程","permalink":"http://ioscoding.cn/categories/网络和线程/"}],"tags":[{"name":"GCD","slug":"GCD","permalink":"http://ioscoding.cn/tags/GCD/"}]},{"title":"深入理解Block","slug":"深入理解Block","date":"2015-08-16T10:49:10.000Z","updated":"2017-05-16T10:54:34.000Z","comments":true,"path":"2015/08/16/深入理解Block/","link":"","permalink":"http://ioscoding.cn/2015/08/16/深入理解Block/","excerpt":"","text":"Block 简介Mac OS X系统10.4及其iOS 4.0后引入了闭包的概念，这项语言特性是作为扩展而加入GCC编译器的。在Foundation框架中大量使用了Block。块就是一个实现某个功能的函数闭包，这个函数闭包可以带有参数，也可以没有参数，可以有返回值也可以没有返回值者，用符号’^’来表示。块在声明的范围内，可以调用块外部的全局变量和局部变量。 void (^someBlock) () = ^{ //A simple block //Implementation: some code //无返回值，无参数 } void (^block) (int a, bool b) = ^(int a, bool b) { //some code //无返回值，带参数 } int (^block2) (int a, bool b) = ^(int a, bool b) { //some code //带参数带返回值 return integerValue; } 需要主意的是，block内部不能改变外部变量，想要在Block中改变变量的值，那么我们只需要在变量声明的时候加上__Block修饰符。 __block int a = 0; void (^block)() = ^{ a = 33; }; Block 的内部结构每个Object-c变量都占据着某个内存区域，block本身也是一个对象，在存放block对象的内存区域中，首个变量是指向class的指针isa，其余内存里包含着对象的其他所有信息。 isa 指针，所有对象都有该指针，用于实现对象相关的功能。 flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。 reserved，保留block函数代码内的变量。 invoke，函数指针，指向具体的 block 实现的函数调用地址。在内存布局中最重要的就是invoke函数指针，指向block的实现代码 descriptor，是指向结构体的指针，每个块里都包含此结构体。block将所捕获的变量指针拷贝到descriptor变量后。表示 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。 variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变 量的地址）复制到了结构体中。 对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的。对于用 __block 修饰的外部变量引用，block是复制其引用地址来实现访问 全局block/堆block/栈block定义block的时候，其所占的内存区域是分配在栈中的。在 Objective-C 语言中，一共有 3 种类型的 block： _NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量 _NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁 _NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁 下面的这段代码在执行的时候就很危险： void (^block)(); int a = 3; if (a &gt; 0) { block = ^ { NSLog(@&quot;Block A&quot;) }; } else { block = ^ { NSLog(@&quot;Block B&quot;) }; } 在定义if else 语句中的两个block都分配在栈内存区域，编译器会给每个block分配好内存，然而等离开相应的范围后，编译器有可能会把分配给块的内存覆盖掉。于是这两个块只能保障在对应的if else语句范围内有效，这样的代码运行起来就会出现问题。为解决此问题，可以给block对象发送copy消息以拷贝到堆空间里。一旦复制到堆上，block就成了带引用计数器的对象了。后续的复制操作都不会真的执行复制，只是递增块对象的应用计数器。 以下代码就是安全的： void (^block)(); int a = 3; if (a &gt; 0) { block = [^{ NSLog(@&quot;Block A&quot;) } copy]; } else { block = [^{ NSLog(@&quot;Block B&quot;) } copy]; } 与全局变量类似，全局块所使用的内存区域，在编译期就已经完全确定了，全局块可以声明在全局内存里。下面就是一个简单的全局块： void (^block) () = ^ { NSLog(@&quot;this is a global block&quot;); } 使用Block小技巧Tip 1 为常见block类型创建块，声明变量时，要把名称放在类型中间：typedef int (^BLOCKSOME) (bool flag, int value); BLOCKSOME block = ^(bool flag, int value) { //some code }; Tip 2用块引用及其所属对象时，不要保留闭环，防止出现return cycle。如使用weakself来防止return cycle： __weak ViewController *wself = self; 定义一个wself变量并加上__weak修饰符，在Block代码块中，所有需要self的地方都用wself来替代。这样就不会增加引用计数，所以Block持有self对象也就不会造成循环引用，从而造成内存泄漏。 参考文章：http://blog.devtang.com/2013/07/28/a-look-inside-blocks/","raw":null,"content":null,"categories":[{"name":"网络和线程","slug":"网络和线程","permalink":"http://ioscoding.cn/categories/网络和线程/"}],"tags":[{"name":"Block","slug":"Block","permalink":"http://ioscoding.cn/tags/Block/"}]},{"title":"GCD概要及实现原理","slug":"GCD概要及实现原理","date":"2015-07-16T02:49:43.000Z","updated":"2017-05-16T10:54:00.000Z","comments":true,"path":"2015/07/16/GCD概要及实现原理/","link":"","permalink":"http://ioscoding.cn/2015/07/16/GCD概要及实现原理/","excerpt":"","text":"GCDGrand Central Dispatch（GCD）是Apple开发的一个多核编程的解决方法。该方法在MacOSX10.6雪豹中首次推出，并随后被引入到了iOS4.0中。GCD是一个替代诸如NSThread, NSOperationQueue等技术的很高效和强大的技术。GCD能够帮助我们使用非常简洁高效的方法实现复杂繁琐的多线程编程。 下面的例子列举了简单的异步线程处理，在后台处理完耗时的程序之后，在主线程更新UI。 12345678910111213dispatch_async(queue, ^&#123; /* * ... * 长时间处理的Code */ //处理结束，主线程更新UI // 使用dispatch_get_main_queue() 获得主线程 dispatch_async(dispatch_get_main_queue(), ^&#123; // ... code // 执行需要在主线程执行的更新UI代码 &#125;); &#125;); GCD的实现原理简单来说，GCD的实现需要使用这些工具： 用于管理追加的Block的C语言实现的FIFO队列 Atomic函数中实现的额用于排他控制的轻量级信号 用于管理线程的C语言层实现的一些容器 通常，应用程序中编写的线程管理应用的代码要在系统iOS和OS X的核心XNU内核级上实现。因此，无论编程人员如何努力编写管理线程的代码，在性能方面也不可能胜过XNU内核级所实现的GCD。 使用GCD要比使用pthreads和NSThread这些一般的多线程编程API更好。并且，如果使用GCD就不必编写为操作线程反复出现的类似的代码(这被称为固定源代码片段)，而可以在线程中集中实现处理内容。我们尽量多使用GCD或者使用了Cocoa框架GCD的NSOperationQueue类等API。 用于实现Dispatch Queue而使用的软件组件。 组件名称 提供技术 libdispatch Dispatch Queue Libc(pthreads) pthread_workqueue XNU内核 workqueue 编程人员所使用GCD的API全部包含在libdispatch库中的C语言函数。Dispatch Queue通过结构体和链表，被实现为FIFO队列。FIFO队列管理是通过dispatch_async函数所追加的Block。 Block并不是直接加入FIFO队列，而是先加入Dispatch Continuation这一==dispatch_continuation_t==类型结构体中，然后再加入FIFO队列。该Dispatch Continuation用于记忆Block所属的Dispatch Group和其他一些信息，相当于一般常说的执行上下文。 Dispatch Queue可通过==dispatch_set_target_queue==函数设定，可以设定执行该Dispatch Queue处理的Dispatch Queue为目标。该目标可像串珠子一样，设定多个连接在一起的Dispatch Queue。但是在连接串的最后必须设定为Main Dispatch Queue，或各种优先级的Global Dispatch Queue，或是准备用于Serial Dispatch Queue的各种优先级的Global Dispatch Queue。 Main Dispatch Queue在RunLoop 中执行Block。 Global Dispatch Queue有如下8中： 12345678Global Dispatch Queue(High Priority)Global Dispatch Queue(Default Priority)Global Dispatch Queue(Low Priority)Global Dispatch Queue(Background Priority)Global Dispatch Queue(High Overcommit Priority)Global Dispatch Queue(Default Overcommit Priority)Global Dispatch Queue(Low Overcommit Priority)Global Dispatch Queue(Background Overcommit Priority) 优先级中附有Overcommit的Global Dispatch Queue使用在Serial Dispatch Queue中。如Overcommit 这个名称所示，不管系统状态如何，都会强制生成线程的Dispatch Queue。这8种Global Dispatch Queue各使用1个pthread_workqueue。GCD初始化时，使用pthread_workqueue_create_np函数生成pthread_workqueue。 pthread_workqueue包含在Libc提供的pthreads API中。其使用bsdthread_register和workq_open系统调用，在初始化XNU内核的workqueue之后获取workqueue信息。 XNU内核持有4中workqueue： 1234WORKQUEUE_HIGH_PRIORITYWORKQUEUE_DEFAULT_PRIORITYWORKQUEUE_LOW_PRIORITYWORKQUEUE_BG_PRIORITY 以上为4中执行优先级的workqueue。该执行优先级与Global Dispatch Queue的4种执行优先级相同。 下面看一下Dispatch Queue中执行Block的过程。当在Global Dispatch Queue中执行Block时，libdispatch从Global Dispatch Queue自身的FIFO队列中提出Dispatch Continuation，调用pthread_workqueue_additem_np函数。将该Global Dispatch Queue自身、符合其优先级的workqueue信息以及为执行Dispatch Continuation的回调函数等传递给参数。 该线程虽然与iOS和OS X中通常使用的线程大致相同，但是有一部分pthread API不能使用。详细信息科参考苹果的官方文档《并列编程指南》的“与POSIX线程的互换性”一节。 另外，因为workqueue生成的线程在实现用于workqueue的线程计划表中运行，所以与一般线程的上下文切换不同。这里也隐藏着使用GCD的原因。 Block执行结束后，进行通知Dispatch Group结束、释放Dispatch Continuation等处理，开始准备执行加入到Globar Dispatch Queue的下一个Block。 Dispatch SourceGCD中除了主要的Dispatch Queue外，还有不太引人注目的Dispatch Source。它是BSD系内核惯有功能kqueue的包装。 kqueue是XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。其CPU负荷非常小，尽量不占用资源。kqueue可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种。 Dispatch Source可处理以下事件： 12345678910DISPATCH_SOURCE_TYPE_DATA_ADD 变量增加DISPATCH_SOURCE_TYPE_DATA_OR 变量ORDISPATCH_SOURCE_TYPE_MACH_SEND MACH端口发送DISPATCH_SOURCE_TYPE_MACH_RECV MACH端口接收DISPATCH_SOURCE_TYPE_PROC 检测到与进程相关的事件DISPATCH_SOURCE_TYPE_READ 可读取文件映像DISPATCH_SOURCE_TYPE_SIGNAL 接收信号DISPATCH_SOURCE_TYPE_TIMER 定时器DISPATCH_SOURCE_TYPE_VNODE 文件系统有变更DISPATCH_SOURCE_TYPE_WRITE 可写入文件映像 事件发生时，在指定的Dispatch Queue中可执行事件的处理。下面我们使用DISPATCH_SOURCE_TYPE_READ，异步读取文件映像。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970* __block size_t total = 0; size_t size = 1024 * 10;//要读取的字节数 char * buff = (char *)malloc(size); /* * 设定为异步映像 */ fcntl(sockfd, F_SETFL, O_NONBLOCK); /* * 获取用于追加事件处理的Global Dispatch Queue */ dispatch_queue_t queue = dispatc_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); /* * 基于READ事件作成Dispatch Source */ dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, sockfd, 0 , queuq); /* * 指定发生READ事件时执行的处理 */ dispatch_source_set_event_handler(source, ^&#123; /* * 获取可读取的字节数 */ size_t available = dispatch_source_get_data(source); /* * 从映像中读取 */ int length = read(sockfd, buff, available); /* * 发生错误时取消Dispatch Source */ if (length &lt; 0) &#123; // 错误处理 dispatch_source_cancel(source); &#125; total += length; if (total == size) &#123; // buff 的处理 // 处理结束，取消Dispatch Source dispatch_source_cancel(source); &#125; &#125;); /* * 指定取消Dispatch Source时的处理 */ dispatch_source_set_cancel_handler(source, ^&#123; free(buff); close(sockfd); /* * 释放Dispatch Source(自身) */ dispatch_release(source); &#125;); /* * 启动Dispatch Source */ dispatch_resume(source); 与上面代码非常相似的代码，使用在了Core Foundation框架的用于异步网络的API CFSocket中。因为Foundation框架的异步网络API是通过CFSocket实现的，所以可享受到仅使用Foundation框架的Dispatch Source(即GCD)带来的好处。 参考文档 《Objective-C 高级编程iOS 与OS X多线程和内存管理》 《Effective Objective-C 2.0》 《ConcurrencyProgrammingGuide》","raw":null,"content":null,"categories":[{"name":"网络和线程","slug":"网络和线程","permalink":"http://ioscoding.cn/categories/网络和线程/"}],"tags":[{"name":"GCD","slug":"GCD","permalink":"http://ioscoding.cn/tags/GCD/"}]},{"title":"Sqlite常用语句","slug":"Sqlite3 常用语句","date":"2014-07-16T06:49:43.000Z","updated":"2017-05-16T10:54:16.000Z","comments":true,"path":"2014/07/16/Sqlite3 常用语句/","link":"","permalink":"http://ioscoding.cn/2014/07/16/Sqlite3 常用语句/","excerpt":"","text":"Creat TableCREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型 CREATE TABLE database_name.table_name( column1 datatype PRIMARY KEY(one or more columns), ..... columnN datatype,); Delete tableDROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。一但一个表使用此命令被删除，表中所有信息也将永远丢失。 DROP TABLE database_name.table_name; InsertINSERT INTO 语句用于向数据库的某个表中添加新的数据行。INSERT INTO 语句有两种基本语法，如下所示： INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) VALUES (value1, value2, value3,...valueN); column1为列名 INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN); SELCTSELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。使用方法： 1 SELECT column1, column2, columnN FROM table_name; 2 SELECT * FROM table_name; SQLite 算术运算符假设变量 a=10，变量 b=20，则：| 运算符 | 描述 | 实例 || :—— | :—— | :—— ||+ |加法 - 把运算符两边的值相加 | a + b 将得到 30||- |减法 - 左操作数减去右操作数 | a - b 将得到 -10|| |乘法 - 把运算符两边的值相乘 | a b 将得到 200||/| 除法 - 左操作数除以右操作数 | b / a 将得到 2||%| 取模 - 左操作数除以右操作数后得到的余数| b % a will give 0| SQLite 表达式SELECT column1, column2, columnN FROM table_name WHERE [CONTION | EXPRESSION]; WHEREWHERE 子句用于指定从一个表或多个表中获取数据的条件。如果满足给定的条件，即为真（true）时，则从表中返回特定的值。您可以使用WHERE子句来过滤记录，只获取需要的记录。WHERE子句不仅可用在SELECT语句中，它也可用在 UPDATE、DELETE 语句中 SELECT column1, column2, columnN FROM table_name WHERE [condition] AND/ORAND 和 OR 运算符用于编译多个条件来缩小在 SQLite 语句中所选的数据。 AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。使用 AND 运算符时，只有当所有条件都为真（true）时，整个条件为真（true）。例如，只有当 condition1 和 condition2 都为真（true）时，[condition1] AND [condition2] 为真（true） OR 运算符也用于结合一个 SQL 语句的 WHERE 子句中的多个条件。使用 OR 运算符时，只要当条件中任何一个为真（true）时，整 个条件为真（true）。例如，只要当 condition1 或 condition2 有一个为真（true）时，[condition1] OR [condition2] 为真（true）。 UpdateUPDATE 查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。带有 WHERE 子句的 UPDATE 查询的基本语法如下： UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition]; DeleteDELETE 查询用于删除表中已有的记录。可以使用带有 WHERE 子句的 DELETE 查询来删除选定行，否则所有的记录都会被删除。下面的语句table所有记录都会被删除。 DELETE FROM table_name 带有 WHERE 子句的 DELETE 查询的基本语法如下： DELETE FROM table_name WHERE [condition]; 可以使用 AND 或 OR 运算符来结合 N 个数量的条件。 Like LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用： 百分号 （%） 下划线 （）百分号（%）代表零个、一个或多个数字或字符。下划线（）代表一个单一的数字或字符。这些符号可以被组合使用。 SELECT FROM table_name WHERE column LIKE ‘XXXX%’ or SELECT FROM table_name WHERE column LIKE ‘%XXXX%’ or SELECT FROM tablename WHERE column LIKE ‘XXXX‘ or SELECT FROM table_name WHERE column LIKE ‘_XXXX’ or SELECT FROM table_name WHERE column LIKE ‘XXXX‘ 例如：|语句| 描述|| :——| :——||WHERE SALARY LIKE ‘200%’| 查找以 200 开头的任意值||WHERE SALARY LIKE ‘%200%’| 查找任意位置包含 200 的任意值||WHERE SALARY LIKE ‘00%’| 查找第二位和第三位为 00 的任意值||WHERE SALARY LIKE ‘2%_%’| 查找以 2 开头，且长度至少为 3 个字符的任意值||WHERE SALARY LIKE ‘%2’| 查找以 2 结尾的任意值||WHERE SALARY LIKE ‘_2%3’| 查找第二位为 2，且以 3 结尾的任意值||WHERE SALARY LIKE ‘2___3’| 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值| GlobGLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。 星号 （*） 问号 （?） 星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。 和 ? 的基本语法如下： SELECT FROM table_name WHERE column GLOB ‘XXXX*’ or SELECT FROM table_name WHERE column GLOB ‘XXXX‘ or SELECT FROM table_name WHERE column GLOB ‘XXXX?’ or SELECT FROM table_name WHERE column GLOB ‘?XXXX’ or SELECT FROM table_name WHERE column GLOB ‘?XXXX?’ or SELECT FROM table_name WHERE column GLOB ‘????’ 您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。实例。下面一些实例演示了 带有 ‘‘ 和 ‘?’ 运算符的 GLOB 子句不同的地方：|语句| 描述|| :——| :——||WHERE SALARY GLOB ‘200‘| 查找以 200 开头的任意值||WHERE SALARY GLOB ‘200‘| 查找任意位置包含 200 的任意值||WHERE SALARY GLOB ‘?00‘| 查找第二位和第三位为 00 的任意值||WHERE SALARY GLOB ‘2??’| 查找以 2 开头，且长度至少为 3 个字符的任意值||WHERE SALARY GLOB ‘2’| 查找以 2 结尾的任意值||WHERE SALARY GLOB ‘?2*3’| 查找第二位为 2，且以 3 结尾的任意值||WHERE SALARY GLOB ‘2???3’| 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值| LIMITLIMIT 子句用于限制由 SELECT 语句返回的数据数量 ELECT column1, column2, columnN FROM table_name LIMIT [no of rows] ORDER BYORDER BY子句是用来基于一个或多个列按升序或降序顺序排列数据. SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC]; GROUP BYGROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。 SELECT column-list FROM table_name WHERE [ conditions ] GROUP BY column1, column2....columnN ORDER BY column1, column2....columnN HAVINGHAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。下面是 HAVING 子句在 SELECT 查询中的位置： SELECT FROM WHERE GROUP BY HAVING ORDER BY 在一个查询中，HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。下面是包含 HAVING 子句的 SELECT 语句的语法： SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2","raw":null,"content":null,"categories":[{"name":"网络和线程","slug":"网络和线程","permalink":"http://ioscoding.cn/categories/网络和线程/"}],"tags":[{"name":"Sqlite","slug":"Sqlite","permalink":"http://ioscoding.cn/tags/Sqlite/"}]}]}